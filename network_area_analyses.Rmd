---
title: "MS Network Area AF"
author: "Carine Emer"
date: "12/12/2018"
output: html_document
---

updating code from "metanetwork analyses March 2017.Rmd"(setwd("~/Dropbox/Seed dispersal data Atlantic/updated names/quanti")


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r set working directory}
setwd("~/Dropbox/MS network area AF/Analyses/network_area")
```


```{r packages}
library(bipartite); library(vegan); library(MuMIn)
library(lme4);library(nlme); library(fossil)
library(bipartiteD3); library(reshape2); library(reshape)

library(r2d3)
library(bipartite)
library(purrr) 
library(dplyr) 
library(tidyr) 
library(stringr)
library(tibble)
library(RColorBrewer)

library(bipartiteD3)
library(ggplot2)
library("cowplot")




```

```{r input data}
setwd("~/Dropbox/MS network area AF/Analyses/network_area/data")
restoredPira<-read.csv("vivian quanti.csv",head=T,row.names=1)
fragmentRC<-read.csv("w34 Athie RC.csv",head=T,row.names=1) 
Cardoso<-read.csv("w44 Castro Cardoso.csv",head=T,row.names=1) 
RebioPcAntas<-read.csv("w30 Correia PcAntas.csv",head=T,row.names=1) 
fragmentMG<-read.csv("w36 Fadini MG.csv",head=T,row.names=1) 
restored15<-read.csv("fe15 quanti.csv",head=T,row.names=1) 
restored25<-read.csv("fe25 quanti.csv",head=T,row.names=1) 
restored57<-read.csv("fe57 quanti.csv",head=T,row.names=1) 
StaGenebra<-read.csv("w35 Galetti Pizo.csv",head=T,row.names=1) 
fragmentSP<-read.csv("w32 Hasui.csv",head=T,row.names=1) 
IAnchieta<-read.csv("w28 Kaiser original.csv",head=T,row.names=1) 
FAraucaria<-read.csv("w33 Kindel.csv",head=T,row.names=1) 
Itatiba<-read.csv("pizo quanti.csv",head=T,row.names=1) 
Intervales<-read.csv("w37 Wesley.csv",head=T,row.names=1)
CBotelho<-read.csv("w95 Botelho.csv",head=T,row.names=1)
fragmentRJ<-read.csv("w93 Rafael UFRJ.csv",head=T,row.names=1)

data<-read.csv("final_results_communities.csv", header=T) # original = CArdoso and Anchieta without added data on E. edulis, Clusia and Cryptocharia, removed all Psittacidae

save.image("network_area.RData")

```

```{r modularity}
comm<-list(Intervales,CBotelho,Cardoso,RebioPcAntas,IAnchieta,fragmentMG,
           FAraucaria,StaGenebra,Itatiba,fragmentRC,restored57,
           restored15,restored25,fragmentSP,restoredPira,fragmentRJ)
mod<-sapply(comm,computeModules)
mod[[1]]
mod_comm<-c(mod[[1]]@likelihood,mod[[2]]@likelihood,mod[[3]]@likelihood,mod[[4]]@likelihood,mod[[5]]@likelihood,mod[[6]]@likelihood,mod[[7]]@likelihood,mod[[8]]@likelihood,mod[[9]]@likelihood,mod[[10]]@likelihood,mod[[11]]@likelihood,mod[[12]]@likelihood,mod[[13]]@likelihood,mod[[14]]@likelihood,mod[[15]]@likelihood,mod[[16]]@likelihood)

data<-cbind(data,mod)

#############

Msig <- function (x, y)  {
    require(bipartite)
    # mat is the input matrix for which M is tested
    # mlike is the observed mean M value
    nulls <- nullmodel(x, N=100, method=3) ## 2 = swapweb, connectance and marginal totals constant (ie, constrait degree for sites and interactions/spp)
    modules.nulls <- sapply(nulls, computeModules)
    like.nulls <- sapply(modules.nulls, function(x) x@likelihood)
    z <- (y - mean(like.nulls))/sd(like.nulls)
    p <- 2*pnorm(-abs(z))
}
z_mod1<-Msig(comm[[1]],mod[1])
z_mod2<-Msig(comm[[2]],mod[2])
z_mod3<-Msig(comm[[3]],mod[3])
z_mod4<-Msig(comm[[4]],mod[4])
z_mod5<-Msig(comm[[5]],mod[5])
z_mod6<-Msig(comm[[6]],mod[6])
z_mod7<-Msig(comm[[7]],mod[7])
z_mod8<-Msig(comm[[8]],mod[8])
z_mod9<-Msig(comm[[9]],mod[9])
z_mod10<-Msig(comm[[10]],mod[10])
z_mod11<-Msig(comm[[11]],mod[11])
z_mod12<-Msig(comm[[12]],mod[12])
z_mod13<-Msig(comm[[13]],mod[13])
z_mod14<-Msig(comm[[14]],mod[14])
z_mod15<-Msig(comm[[15]],mod[15])
z_mod16<-Msig(comm[[16]],mod[16])

z_mod<-c(z_mod1,z_mod2,z_mod3,z_mod4,z_mod5,z_mod6,z_mod7,z_mod8,z_mod9,z_mod10,z_mod11,z_mod12,z_mod13,z_mod14,z_mod15,z_mod16)
data<-cbind(data,z_mod)

plot(data$z_mod~data$area_ha)


```

```{r metrics}
#### connectance, wnodf, modularity, 
#H2 is correlated with modularity


plot(log(data$linkdens))
loglinkdens<-log(data$linkdens)

c_comm<-sapply(comm,networklevel, index = "connectance")
h2_comm<-sapply(comm,networklevel, index = "H2")
cor.test(c_comm,h2_comm) # 0.14

wc_comm<-sapply(comm,networklevel, index = "weighted connectance")
cor.test(wc_comm,c_comm) # 0.80

links<-sapply(comm, networklevel, index = "links per species")
cor.test(mod_comm,links) 
plot(links,data$area_ha)

wnodf<-sapply(comm, networklevel, index = "weighted NODF")
cor.test(mod_comm,h2_comm) 
plot(wnodf,mod_comm)
plot(wnodf,h2_comm)

plot(data$evenness~logarea)
cor(data$evenness,data$h2)
cor(data$evenness,data$wnodf)
cor(data$evenness,data$dirt_mod_quanti)


```

```{r correlations}

plot(data$area)
logarea<-log(data$area)
plot(logarea) # better fit

cor(data$area,data$def2Jac) # -0.8
cor(data$area,data$def)
plot(data$def~logarea)

cor(logsize,logarea)
cor(logsize,data$c)
cor(logsize,data$dirt_mod_quanti) ## only one not correlated
cor(logsize,data$wnodf)
cor(logsize,data$h2)

cor(logsize,data$intensity) #0.1
cor(logsize,loglinkdens) #0.9
cor(logsize,logarea) #0.69
cor(logsize,data$dirt_mod_quanti)
cor(logsize,data$c)
cor(logsize,data$wnodf)
cor(data$dirt_mod_quanti,data$h2)


data1<-data[,c(14,19,21,23,25)]
data2<-cbind(data1,logarea)
data2<-cbind(data2,logsize)

pairs(data2, pch = 19)


```


```{r sampling completeness}
str(comm)
chao<-sapply(comm, chao1)
chao
data<-cbind(data,chao)
data$chao


```

```{r models}
####logs= log size of the network and logarea = log(area)
plot((data$size))
logsize<-log(data$size) ## better fit
plot(logsize)

plot(data$area)
logarea<-log(data$area)
plot(logarea) # better fit

################animals##########################
#animals
hist(data$n.animals)
hist(log(data$n.animals))
animals<-log(data$n.animals)
## first, REML to compare fixed terms and variable random or correlation structure -Zuur p 90 e 169
m1<-gls(animals ~ intensity+logarea+forest.type, data=data,method="REML")# 
#m2<-gls(plants ~ logs+def2Jac*logarea, data=data,method="REML")

m1a<-update(m1,correlation=corSpher(form=~x+y))
m1b<-update(m1,correlation=corLin(form=~x+y))
m1c<-update(m1,correlation=corRatio(form=~x+y))
m1d<-update(m1,correlation=corGaus(form=~x+y))
m1e<-update(m1,correlation=corExp(form=~x+y))

AIC(m1,m1a,m1b,m1c,m1d,m1e) ### m1 best model

### second, fit ML for best model selection Zuur, pg 90
m1<-gls(animals~ intensity+logarea+forest.type, data=data, method="ML")
summary(m1)
dd<-dredge(m1)
print(dd)
summary(get.models(dd,1)[[1]])

## finally, refit best models with REML for final results
m1best<-m1<-gls(animals~logarea, data=data, method="REML")
summary (m1best)

m2best<-gls(animals~intensity+logarea, data=data, method="REML")
summary (m2best)

###############plants##########################
#plants
hist(data$n.plants)
hist(log(data$n.plants))
plants<-log(data$n.plants)
## first, REML to compare fixed terms

m1<-gls(plants ~ intensity+logarea+forest.type, data=data,method="REML")# 
#m1<-gls(plants ~ logs+logarea+forest.type, data=data,method="REML")

#AIC(m1,m2)

m1a<-update(m1,correlation=corSpher(form=~x+y))
m1b<-update(m1,correlation=corLin(form=~x+y))
m1c<-update(m1,correlation=corRatio(form=~x+y))
m1d<-update(m1,correlation=corGaus(form=~x+y))
m1e<-update(m1,correlation=corExp(form=~x+y))

AIC(m1,m1a,m1b,m1c,m1d,m1e) ### m1 best model

### second, fit ML for best model selection Zuur, pg 90
m1<-gls(plants~ intensity+logarea+forest.type, data=data, method="ML", correlation=corSpher(form=~x+y))
summary(m1)
dd<-dredge(m1)
print(dd)
summary(get.models(dd,1)[[1]])


## finally, refit best models with REML for final results
m1best<-m1<-gls(plants ~ logarea, data=data, method="REML",correlation=corSpher(form=~x+y))
summary (m1best)

##############interactions###########################
hist(data$n.interactions)
hist(log(data$n.interactions))
interactions<-log(data$n.interactions)

## first, REML to compare fixed terms
m1<-gls(interactions ~ intensity+logarea+forest.type, data=data,method="REML")# 
#m1<-gls(interactions ~ logsize+logarea+forest.type, data=data,method="REML")

m1a<-update(m1,correlation=corSpher(form=~x+y))
m1b<-update(m1,correlation=corLin(form=~x+y))
m1c<-update(m1,correlation=corRatio(form=~x+y))
m1d<-update(m1,correlation=corGaus(form=~x+y))
m1e<-update(m1,correlation=corExp(form=~x+y))

AIC(m1,m1a,m1b,m1c,m1d,m1e) ### m1 best model

### second, fit ML for best model selection Zuur, pg 90
m1<-gls(interactions~ intensity+logarea+forest.type, data=data, method="ML")
summary(m1)
dd<-dredge(m1)
print(dd)
summary(get.models(dd,1)[[1]])


## finally, refit best models with REML for final results
m1best<-m1<-gls(interactions ~ logarea+intensity, data=data, method="REML")
summary (m1best)


##############connectance###########################
hist(data$c)
## first, REML to compare fixed terms
m1<-gls(log(c+0.0649)/(1-c+0.0649) ~ intensity+logarea+forest.type, data=data,method="REML")# 
#m1<-gls(log(c+0.0649)/(1-c+0.0649) ~ logsize+logarea+forest.type, data=data,method="REML")
#m3<-gls(c ~ logsize+res1+forest.type, data=data,method="REML")

#AIC(m1,m2)

m1a<-update(m1,correlation=corSpher(form=~x+y))
m1b<-update(m1,correlation=corLin(form=~x+y))
m1c<-update(m1,correlation=corRatio(form=~x+y))
m1d<-update(m1,correlation=corGaus(form=~x+y))
m1e<-update(m1,correlation=corExp(form=~x+y))

AIC(m1,m1a,m1b,m1c,m1d,m1e) ### m1 best model

### second, fit ML for best model selection Zuur, pg 90
m1<-gls(log(c+0.0649)/(1-c+0.0649)~ intensity+logarea+forest.type, data=data, method="ML")
summary(m1)
dd<-dredge(m1)
print(dd)
summary(get.models(dd,1)[[1]])
summary(get.models(dd,2)[[1]])

## finally, refit best models with REML for final results
m1best<-gls(log(c+0.0649)/(1-c+0.0649) ~ 1, data=data, method="REML")
summary (m1best)

m1best<-gls(log(c+0.0649)/(1-c+0.0649) ~ intensity, data=data, method="REML")
summary (m1best)

##############modularity###########################
hist(data$dirt_mod_quanti)
## first, REML to compare fixed terms
m1<-gls(log(dirt_mod_quanti+0.2216441)/(1-dirt_mod_quanti+0.2216441) ~ intensity+logarea+forest.type, data=data,method="REML")# 
#m1<-gls(log(dirt_mod_quanti+0.2216441)/(1-dirt_mod_quanti+0.2216441) ~ logsize+logarea+forest.type, data=data,method="REML")

m1a<-update(m1,correlation=corSpher(form=~x+y))
m1b<-update(m1,correlation=corLin(form=~x+y))
m1c<-update(m1,correlation=corRatio(form=~x+y))
m1d<-update(m1,correlation=corGaus(form=~x+y))
m1e<-update(m1,correlation=corExp(form=~x+y))

AIC(m1,m1a,m1b,m1c,m1d,m1e) ### m1 best model

### second, fit ML for best model selection Zuur, pg 90
m1<-gls(log(dirt_mod_quanti+0.2216441)/(1-dirt_mod_quanti+0.2216441)~ intensity+logarea+forest.type, data=data, method="ML")
summary(m1)
dd<-dredge(m1)
print(dd)
summary(get.models(dd,1)[[1]])
summary(get.models(dd,2)[[1]])

## finally, refit best models with REML for final results
m1best<-m1<-gls(log(dirt_mod_quanti+0.2216441)/(1-dirt_mod_quanti+0.2216441) ~ logsize, data=data, method="REML")
summary (m1best)

##############Nestedness###########################
hist(data$wnodf)
## first, REML to compare fixed terms
m1<-gls(wnodf ~ intensity+logarea+forest.type, data=data,method="REML")# 
#m2<-gls(wnodf ~ logsize+logarea+forest.type, data=data,method="REML")

m1a<-update(m1,correlation=corSpher(form=~x+y))
m1b<-update(m1,correlation=corLin(form=~x+y))
m1c<-update(m1,correlation=corRatio(form=~x+y))
m1d<-update(m1,correlation=corGaus(form=~x+y))
m1e<-update(m1,correlation=corExp(form=~x+y))

AIC(m1,m1a,m1b,m1c,m1d,m1e) ### m1 best model

### second, fit ML for best model selection Zuur, pg 90
m1<-gls(wnodf~ intensity+logarea+forest.type, data=data, method="ML")
summary(m1)
dd<-dredge(m1)
print(dd)
summary(get.models(dd,1)[[1]])
summary(get.models(dd,2)[[1]])

## finally, refit best models with REML for final results
m1best<-m1<-gls(wnodf ~ intensity+logarea, data=data, method="REML")
summary (m1best)



##############H2###########################
hist(data$h2)

## first, REML to compare fixed terms
m1<-gls(log(h2+0.0673)/(1-h2+0.0673) ~ intensity+logarea+forest.type, data=data,method="REML")# 
#m1<-gls(log(h2+0.0673)/(1-h2+0.0673) ~ logsize+logarea+forest.type, data=data,method="REML")

AIC(m1,m2)

m1a<-update(m1,correlation=corSpher(form=~x+y))
m1b<-update(m1,correlation=corLin(form=~x+y))
m1c<-update(m1,correlation=corRatio(form=~x+y))
m1d<-update(m1,correlation=corGaus(form=~x+y))
m1e<-update(m1,correlation=corExp(form=~x+y))

AIC(m1,m1a,m1b,m1c,m1d,m1e) ### m1 best model

### second, fit ML for best model selection Zuur, pg 90
m1<-gls(log(h2+0.0673)/(1-h2+0.0673)~ intensity+logarea+forest.type, data=data, method="ML", correlation=corSpher(form=~x+y))
summary(m1)
dd<-dredge(m1)
print(dd)
summary(get.models(dd,1)[[1]])
summary(get.models(dd,2)[[1]])

## finally, refit best models with REML for final results
m1best<-m1<-gls(log(h2+0.0673)/(1-h2+0.0673) ~ 1, data=data, method="REML",correlation=corSpher(form=~x+y))
summary (m1best)



############## evenness ##########################

## first, REML to compare fixed term
m1<-gls(log(evenness+0.5514)/(1-evenness+0.5514) ~ intensity+logarea+forest.type, data=data,method="REML")# 
#m1<-gls(log(evenness+0.5514)/(1-evenness+0.5514) ~ logsize+logarea+forest.type, data=data,method="REML")
#m3<-gls(c ~ logsize+res1+forest.type, data=data,method="REML")


m1a<-update(m1,correlation=corSpher(form=~x+y))
m1b<-update(m1,correlation=corLin(form=~x+y))
m1c<-update(m1,correlation=corRatio(form=~x+y))
m1d<-update(m1,correlation=corGaus(form=~x+y))
m1e<-update(m1,correlation=corExp(form=~x+y))

AIC(m1,m1a,m1b,m1c,m1d,m1e) ### m1 best model

### second, fit ML for best model selection Zuur, pg 90
m1<-gls(log(evenness+0.5514)/(1-evenness+0.5514)~ intensity+logarea+forest.type, data=data, method="ML")
summary(m1)
dd<-dredge(m1)
print(dd)
summary(get.models(dd,1)[[1]])
summary(get.models(dd,2)[[1]])

## finally, refit best models with REML for final results
m1best<-gls(log(evenness+0.5514)/(1-evenness+0.5514) ~ 1, data=data, method="REML")
summary (m1best)

m2best<-gls(log(evenness+0.5514)/(1-evenness+0.5514) ~ logarea, data=data, method="REML")
summary (m2best)


############# links per species ##########################
links
## first, REML to compare fixed term
m1<-gls(links ~ intensity+logarea+forest.type, data=data,method="REML")# 

m1a<-update(m1,correlation=corSpher(form=~x+y))
m1b<-update(m1,correlation=corLin(form=~x+y))
m1c<-update(m1,correlation=corRatio(form=~x+y))
m1d<-update(m1,correlation=corGaus(form=~x+y))
m1e<-update(m1,correlation=corExp(form=~x+y))

AIC(m1,m1a,m1b,m1c,m1d,m1e) ### m1 best model

### second, fit ML for best model selection Zuur, pg 90
m1<-gls(links~ intensity+logarea+forest.type, data=data, method="ML")
summary(m1)
dd<-dredge(m1)
print(dd)
summary(get.models(dd,1)[[1]])

## finally, refit best models with REML for final results
m1best<-gls(links ~ logarea, data=data, method="REML")
summary (m1best)

```

```{r ggplot}

## ≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠ function to set a legend for multiple panels
#library(gridExtra)
#get_legend<-function(myggplot){
  #tmp <- ggplot_gtable(ggplot_build(myggplot))
  #leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
  #legend <- tmp$grobs[[leg]]
  #return(legend)
#}
## ≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠ 
# 1. Create the plots
#++++++++++++++++++++++++++++++++++
# 2. Save the legend
#+++++++++++++++++++++++
#legend <- get_legend(bp)
# 3. Remove the legend from the plot
#+++++++++++++++++++++++
#bp <- bp + theme(legend.position="none")
# 4. Arrange ggplot2 graphs with a specific width

### defaunation index used in Science paper
def<-c(0.557,0.615,0.626,0.926,0.958,0.838,0.96,0.837,0.897,0.963,0.986,
       0.971,0.95,0.952,0.956,0.971)
data<-cbind(data,def)
#1. Scatter plots
sp1 <- ggplot(data, aes(x = logarea, y = (n.animals), size = 4, fill=def)) +
             geom_point(shape = 21) +
             labs(x = "", y = "N bird species")
sp1<-sp1 + scale_fill_continuous(low = "#56B1F7", high = "#132B43") +
           theme(legend.position ="none")
sp1
## ≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠
sp2 <- ggplot(data, aes(x = logarea, y = log(n.plants), size = 4, fill = def)) +
             geom_point(shape = 21) +
             labs(x = "", y = "N plant species (log)")
sp2<-sp2 + scale_fill_continuous(low = "#56B1F7", high = "#132B43") +
           theme(legend.position ="none")
## ≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠
sp3 <- ggplot(data, aes(x = logarea, y = n.interactions, fill = Defaunation)) +
             geom_point(shape = 21, size = 4) +
             labs(x = "", y = "N interactions") +
             theme(legend.position ="none")
 
sp3<-sp3 + scale_fill_continuous(low = "#56B1F7", high = "#132B43")

# 2. Save the legend
#+++++++++++++++++++++++
#legend <- get_legend(sp3)

eve<-data$evenness+0.5514/(1-data$evenness+0.5514)
#1. Scatter plots
sp4 <- ggplot(data, aes(x = logarea, y =eve, size = 4, fill = def)) +
             geom_point(shape = 21) +
             labs(x = "", y = "Evenness (logit-transf)")
sp4<-sp4 + scale_fill_continuous(low = "#56B1F7", high = "#132B43") +
            theme(legend.position="none")
## ≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠
mod<-log(data$dirt_mod_quanti+0.2216441)/(1-data$dirt_mod_quanti+0.2216441)
sp5 <- ggplot(data, aes(x = logarea, y = mod, size = 4, fill = def)) +
             geom_point(shape = 21) +
             labs(x = "Fragment area (log[ha])", y = "Modularity (logit-transf)")
sp5<-sp5 + scale_fill_continuous(low = "#56B1F7", high = "#132B43") +
          theme(legend.position ="none")
## ≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠
sp6 <- ggplot(data, aes(x = logarea, y = wnodf, size = 4, fill = def)) +
             geom_point(shape = 21) +
             labs(x = "", y = "Weighted nestedness") +
   theme(legend.position ="none")
 
sp6<-sp6 + scale_fill_continuous(low = "#56B1F7", high = "#132B43")

#4 ≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠≠
grid.arrange(sp1, sp2, sp3, legend,
             sp4, sp5, sp6, ncol=4, nrow=2,
             widths = c(6,6,6,2), heights = c(2,2))
```


```{r plot bipartiteD3}

test1<-melt(as.matrix(Intervales))
test1 <- subset(test1, value>0)
test1$webID <- c(rep("Intervales"))

colnames(test1)[1]<-"lower"
colnames(test1)[2]<-"higher"
colnames(test1)[3]<-"freq"

bipartite::frame2webs(test1)-> webtest

bipartite_D3(webtest, PrimaryLab = 'Plants',
            SecondaryLab = 'Birds',
            colouroption = 'brewer',
            Orientation = 'horizontal', ColourBy = 1)


```


```{r networks igraph}

#seed_network<-plotweb(Intervales,text.rot=c(90),labsize=1,y.width.low=0.05,y.width.high=0.05,        arrow="down.center",ybig=1.8, low.y=1.2, high.y=2, high.spacing=.04, low.spacing=0.02,        bor.col.interaction = "grey80",        method="cca", ### check the method if you prefer        col.low="green", col.high="blue", col.interaction = "grey80")

#################
##igraph
m<- Intervales
## transform to edgelist
m1<-melt(as.matrix(m)) 
## select only interactions =1
m2 <- subset(m1, value>0) 

# sets the graph framework
  g=graph.data.frame(m2,directed=FALSE) 
#Check the main properties of the igraph object
V(g)$name

V(g)$color[1:184] = "green"
V(g)$color[185:265] = "blue"

plot(g,
      # Set the drawing mode
      # This package contains several drawing methods; try them!
     layout=layout.circle,
       # Set title
     #main='Ant-myrmecophyte network',
       # Set node sizes
     vertex.size=6,
     # Set node attributes
     #vertex.shape=V(g)$shape,
     vertex.color = V(g)$color,
     # Set link colors
           edge.color = "lightblue",
      # Set link curvature from 0 to 1
           edge.curved=0.3,
      # Set nodes labels
     vertex.label.dist=200,
     vertex.label.color='black',
     vertex.label.font=1,
     vertex.label=V(g)$name,
     vertex.label.cex=0.5
)

#########
m<- restored25
m1<-melt(as.matrix(m)) 
m2 <- subset(m1, value>0) 

g=graph.data.frame(m2,directed=FALSE) 

V(g)$name
V(g)$color[1:23] = "green"
V(g)$color[24:52] = "blue"

plot(g,
     layout=layout.circle,
         vertex.size=6,
         vertex.color = V(g)$color,
               edge.color = "lightblue",
               edge.curved=0.3,
     vertex.label.dist=200,
     vertex.label.color='black',
     vertex.label.font=1,
     vertex.label=V(g)$name,
     vertex.label.cex=0.5
)
```

